import { acceptHMRUpdate, defineStore } from 'pinia'

export const useIndexedDBStore = defineStore('indexedDB ', () => {
  const encryption_store = useEncryptionStore()
  const dbName = 'KeyDatabase'
  const storeName = 'keys'
  let db: IDBDatabase | null = null

  // Initialize the database and the object store for storing keys.
  async function setupIndexedDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request: IDBOpenDBRequest = indexedDB.open(dbName, 1)

      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
        db = (event.target as IDBOpenDBRequest).result
        if (!db.objectStoreNames.contains(storeName))
          db.createObjectStore(storeName)
      }

      request.onsuccess = (event: Event) => {
        resolve((event.target as IDBOpenDBRequest).result)
      }

      request.onerror = (event: Event) => {
        console.error('Error opening IndexedDB:', event)
        reject(new Error('Error opening IndexedDB.'))
      }
    })
  }

  // Store the key pair generated by nacl in IndexedDB.
  async function storeKeyPair() {
    await setupIndexedDB()
    const store_key_pair = new Promise<void>((resolve, reject) => {
      if (!db) {
        console.error('IndexedDB not initialized.')
        reject(new Error('IndexedDB not initialized.'))
        return
      }

      const transaction: IDBTransaction = db.transaction([storeName], 'readwrite')
      const store: IDBObjectStore = transaction.objectStore(storeName)

      store.add(encryption_store.signing_keypair?.publicKey, 'publicKey')
      store.add(encryption_store.signing_keypair?.secretKey, 'privateKey')

      transaction.oncomplete = () => resolve()
      transaction.onerror = event => reject(event)
    })
    await closeDB()
    return store_key_pair
  }

  // Retrieve the key pair from IndexedDB.
  async function retrieveKeyPair(db: IDBDatabase): Promise<{ publicKey: Uint8Array; privateKey: Uint8Array }> {
    await setupIndexedDB()
    const retrieve_key_pair = new Promise((resolve, reject) => {
      const transaction: IDBTransaction = db.transaction([storeName], 'readonly')
      const store: IDBObjectStore = transaction.objectStore(storeName)

      const publicKeyRequest: IDBRequest = store.get('publicKey')
      const privateKeyRequest: IDBRequest = store.get('privateKey')

      publicKeyRequest.onerror = privateKeyRequest.onerror = event => reject(event)

      publicKeyRequest.onsuccess = () => {
        privateKeyRequest.onsuccess = () => {
          resolve({
            publicKey: publicKeyRequest.result as Uint8Array,
            privateKey: privateKeyRequest.result as Uint8Array,
          })
        }
      }
    })
    await closeDB()
    return retrieve_key_pair as Promise<{ publicKey: Uint8Array; privateKey: Uint8Array }>
  }

  async function closeDB() {
    if (db)
      db.close()
  }

  return {
    setupIndexedDB,
    storeKeyPair,
    retrieveKeyPair,
  }
})

if (import.meta.hot)
  import.meta.hot.accept(acceptHMRUpdate(useUtilsStore, import.meta.hot))
